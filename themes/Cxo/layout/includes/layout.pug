doctype html

html(lang=config.language)
  include partial/head.pug
  body
    include partial/profile.pug
    include partial/header.pug
    article#cxo-content-outer.cxo-up
      section#cxo-content-inner
        if body
          div!= body
        else
          block content
    include partial/footer.pug
    // catelog
    if is_post() && theme.toc 
      - let tocTop = typeof theme.intro_height === 'number' ? theme.intro_height : 60
      - let tocStyle = `top: ${tocTop}vh;`
      .toc-wrapper(style = tocStyle)
        .toc-catalog
          i.fa.fa-list 
          span CATALOG
        != toc(page.content, {class: 'toc', list_number: true})
    // top
    i.fa.fa-arrow-up#go-up.close(aria-hidden="true")
    
    //- START: Interactive Ripple Title Logic
    if is_post() && theme.ripple_title && theme.ripple_title.enable
      div#ripple-title-wrapper
        canvas.ripple-canvas

      style.
        #ripple-title-wrapper {
          position: fixed; /* 使用固定定位，相对于视口 */
          pointer-events: none;
          z-index: 10;
        }
        #ripple-title-wrapper .ripple-canvas {
          position: absolute; top: 0; left: 0;
          width: 100%; height: 100%;
        }

      script(type="module").
        import * as THREE from "https://esm.sh/three@0.158.0";
        
        // 使用 window.onload 确保所有资源（包括字体）加载完毕
        window.onload = () => {
          const titleElement = document.querySelector('h1.post-title'); 
          
          if (!titleElement) {
            console.error("Ripple Title: Could not find 'h1.post-title' element.");
          } else {
            const wrapper = document.getElementById('ripple-title-wrapper');
            if (wrapper) {
              
              let scene, camera, renderer, plane, raycaster, hitPlane;
              const pointer = new THREE.Vector2();
              let titleTexture = new THREE.CanvasTexture(document.createElement('canvas'));
              
              function init() {
                updateWrapperPosition(); // 初始化时就定位

                scene = new THREE.Scene();
                const aspect = wrapper.clientWidth / wrapper.clientHeight;
                const camera_distance = wrapper.clientHeight / 2;
                camera = new THREE.OrthographicCamera(-camera_distance * aspect, camera_distance * aspect, camera_distance, -camera_distance, 0.01, 1000);
                camera.position.set(0, 0, 10);
                camera.lookAt(0, 0, 0);

                const canvas = wrapper.querySelector('.ripple-canvas');
                renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                raycaster = new THREE.Raycaster();
                hitPlane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial());
                hitPlane.visible = false; scene.add(hitPlane);

                createTextTexture();
                createPlane();

                window.addEventListener("resize", onWindowResize);
                wrapper.addEventListener("pointermove", onPointerMove);
                wrapper.style.pointerEvents = 'auto';

                animate();
              }

              function updateWrapperPosition() {
                const rect = titleElement.getBoundingClientRect();
                Object.assign(wrapper.style, {
                  top: rect.top + 'px',
                  left: rect.left + 'px',
                  width: rect.width + 'px',
                  height: rect.height + 'px'
                });
              }

              function createTextTexture() {
                const canvas = document.createElement('canvas'); const context = canvas.getContext('2d');
                const style = getComputedStyle(titleElement);
                const font = `${style.fontStyle} ${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
                
                const dpr = window.devicePixelRatio;
                const canvasWidth = wrapper.clientWidth * dpr;
                const canvasHeight = wrapper.clientHeight * dpr;
                
                canvas.width = canvasWidth; canvas.height = canvasHeight;
                context.scale(dpr, dpr);

                context.font = font;
                context.fillStyle = style.color;
                context.textAlign = style.textAlign;
                context.textBaseline = 'middle';
                
                const x = style.textAlign === 'center' ? wrapper.clientWidth / 2 : 0;
                const y = wrapper.clientHeight / 2;

                context.fillText(titleElement.innerText, x, y);
                
                titleElement.style.visibility = 'hidden'; // 使用visibility而不是opacity
                titleTexture.image = canvas;
                titleTexture.needsUpdate = true;
              }

              function createPlane() {
                const geometry = new THREE.PlaneGeometry(wrapper.clientWidth, wrapper.clientHeight, 100, 50);
                const shaderMaterial = new THREE.ShaderMaterial({
                  uniforms: { uTexture: { value: titleTexture }, uDisplacement: { value: new THREE.Vector3(0, 0, 0) } },
                  vertexShader: `
                    varying vec2 vUv; uniform vec3 uDisplacement;
                    float easeInOutCubic(float x) { return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.; }
                    float map(float value, float min1, float max1, float min2, float max2) { return min2 + (value - min1) * (max2 - min2) / (max1 - min1); }
                    void main() {
                      vUv = uv; vec3 new_position = position;
                      float dist = length(uDisplacement.xy - position.xy);
                      float min_distance = 80.0;
                      if (dist < min_distance) {
                        float mapped_dist = map(dist, 0., min_distance, 1., 0.);
                        float ripple_strength = easeInOutCubic(mapped_dist) * 15.0;
                        new_position.z += ripple_strength;
                      }
                      gl_Position = projectionMatrix * modelViewMatrix * vec4(new_position, 1.0);
                    }
                  `,
                  fragmentShader: `varying vec2 vUv; uniform sampler2D uTexture; void main() { gl_FragColor = texture2D(uTexture, vUv); }`,
                  transparent: true, depthWrite: false
                });
                plane = new THREE.Mesh(geometry, shaderMaterial);
                scene.add(plane);
              }

              function onPointerMove(event) {
                const rect = wrapper.getBoundingClientRect();
                pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(hitPlane);
                
                if (intersects.length > 0) {
                  plane.material.uniforms.uDisplacement.value.copy(intersects[0].point);
                }
              }

              function onWindowResize() {
                updateWrapperPosition(); // 窗口变化时重新定位
                
                const aspect = wrapper.clientWidth / wrapper.clientHeight;
                const camera_distance = wrapper.clientHeight / 2;
                
                camera.left = -camera_distance * aspect; camera.right = camera_distance * aspect;
                camera.top = camera_distance; camera.bottom = -camera_distance;
                camera.updateProjectionMatrix();
                
                renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
                
                createTextTexture();
                scene.remove(plane);
                createPlane();
              }

              function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
              }
              
              init();
            }
          }
        };
    //- END: Interactive Ripple Title